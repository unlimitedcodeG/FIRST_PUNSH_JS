<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<script>
			 // 我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。  
			    // 请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。
//			  function Person(){
//			     	
//			     }
//			     var friend =new Person();
//			    Person.prototype={
//			     constructor:Person,
//			     name:"Nicholas",
//			     age:29,
//			     job:"Software Engineer",
//			     sayName:function(){
//			     	alert(this.name);
//			     }
//			    };
//			    friend.sayName();
			    // 原生对象的原型
			    // 原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都采用这种模式创建。所有原生引用类型(Object.Array.String，等等)都在其构造函数的原型上定义了方法。
			    //例如在Array.prototype中可以找到sort()方法，而在String.prototype中可以找到substring()方法，如下所示。
			    alert(typeof Array.prototype.sort);
			    alert(typeof String.prototype.substring)
			     //通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型String添加了名为startsWith()的方法。
			      String.prototype.startsWith=function(text){
			      	return this.indexOf(text)==0;
			      	
			      };
			       var msg ="Hello world!";
			       alert(msg.startsWith("Hello"))
		</script>
	</head>
	<body>
	</body>
</html>
